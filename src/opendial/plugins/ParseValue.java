// =================================================================                                                                   
// Copyright (C) 2011-2015 Pierre Lison (plison@ifi.uio.no)

// Permission is hereby granted, free of charge, to any person 
// obtaining a copy of this software and associated documentation 
// files (the "Software"), to deal in the Software without restriction, 
// including without limitation the rights to use, copy, modify, merge, 
// publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, 
// subject to the following conditions:

// The above copyright notice and this permission notice shall be 
// included in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// =================================================================                                                                   

package opendial.plugins;

import java.util.logging.*;
import java.util.stream.Collectors;
import java.util.Collection;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import opendial.bn.values.StringVal;
import opendial.bn.values.Value;
import opendial.bn.values.ValueFactory;
import opendial.datastructs.Template;

import org.maltparser.concurrent.graph.ConcurrentDependencyGraph;
import org.maltparser.concurrent.graph.ConcurrentDependencyNode;

/**
 * Representation of a dependency parse of a particular utterance. The parse contains
 * the sequence of words (after tokenisation) together with their POS tags and
 * labelled relation to their head.
 * 
 * @author Pierre Lison (plison@ifi.uio.no)
 */
public class ParseValue implements Value {

	// logger
	final static Logger log = Logger.getLogger("OpenDial");

	/**
	 * The list of words together with their POS-tags and dependencies.
	 */
	SortedMap<Integer, FactoredWord> parsedInput;

	/**
	 * Constructs a new parse value from a dependency graph generated by the
	 * MaltParser.
	 * 
	 * @param graph the dependency graph from the MaltParser.
	 */
	public ParseValue(ConcurrentDependencyGraph graph) {
		parsedInput = new TreeMap<Integer, FactoredWord>();
		for (int i = 1; i < graph.nTokenNodes(); i++) {
			ConcurrentDependencyNode node = graph.getTokenNode(i);
			int index = node.getIndex();
			String word = node.getLabel(1);
			String posTag = node.getLabel(3);
			int head = node.getHeadIndex();
			String headRelation = node.getLabel(7);
			FactoredWord fw =
					new FactoredWord(index, word, posTag, head, headRelation);
			parsedInput.put(index, fw);
		}
	}

	/**
	 * Copies the ParseValue
	 * 
	 * @param parsedInput the existing list of factored words
	 */
	public ParseValue(Map<Integer, FactoredWord> parsedInput) {
		this.parsedInput = new TreeMap<Integer, FactoredWord>(parsedInput);
	}

	/**
	 * Returns the hashcode for the parse value.
	 */
	@Override
	public int hashCode() {
		return parsedInput.hashCode();
	}

	/**
	 * Returns a string representation of the parse
	 */
	@Override
	public String toString() {
		String str = "\n";
		for (int i : parsedInput.keySet()) {
			FactoredWord fw = parsedInput.get(i);
			str += fw.toString() + "\n";
		}
		return (str.length() > 0) ? str.substring(0, str.length() - 1) : str;
	}

	/**
	 * Returns true if the object o is a parse with identical elements, and false
	 * otherwise.
	 */
	@Override
	public boolean equals(Object o) {
		if (o instanceof ParseValue) {
			return ((ParseValue) o).parsedInput.equals(parsedInput);
		}
		return false;
	}

	/**
	 * Compares the hashcodes of the two parse values.
	 */
	@Override
	public int compareTo(Value o) {
		return hashCode() - o.hashCode();
	}

	/**
	 * Copies the parse value.
	 */
	@Override
	public Value copy() {
		return new ParseValue(parsedInput);
	}

	/**
	 * Returns the number of (parsed) words
	 * 
	 * @return the number of words
	 */
	@Override
	public int length() {
		return parsedInput.size();
	}

	/**
	 * Returns true if the subvalue is contained in the parse. Two distinct cases are
	 * considered:
	 * <ul>
	 * <li>When subvalue is of the form "(x,y,z)", the method checks whether there
	 * exists a dependency relation between the words (or POS tags) x and z with
	 * dependency label y
	 * <li>When subvalue is a normal string (sequence of tokens separated by space),
	 * the method checks whether the list of factors contains the token sequence as
	 * surface word or POS tag.
	 * </ul>
	 */
	@Override
	public boolean contains(Value subvalue) {
		if (subvalue instanceof StringVal) {
			String str = ((StringVal) subvalue).getString().trim().toLowerCase();
			// First case: contains with a factored word
			if (str.startsWith("(") && str.split(",").length == 5
					&& str.endsWith(")")) {
				Template t = Template.create(str.trim());
				for (FactoredWord fw : parsedInput.values()) {
					if (t.match(fw.toString()).isMatching()) {
						return true;
					}
				}
			}

			// Second case: substring with postags
			else {
				String[] tokens = str.split(" ");
				for (int i : parsedInput.keySet()) {
					for (int j = 0; j < tokens.length
							&& i + j < parsedInput.size() + 1; j++) {
						FactoredWord curW = parsedInput.get(i + j);
						if (!tokens[j].equalsIgnoreCase(curW.word)
								&& !tokens[j].equalsIgnoreCase(curW.posTag)
								&& !tokens[j].equalsIgnoreCase(
										curW.word + "/" + curW.posTag)) {
							break;
						}
						else if (j == tokens.length - 1) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	/**
	 * Returns a collection of string values (one for each factored word).
	 */
	@Override
	public Collection<Value> getSubValues() {
		return parsedInput.values().stream()
				.map(f -> ValueFactory.create(f.toString()))
				.collect(Collectors.toList());
	}

	/**
	 * If value is a parsevalue, concatenates the parse. Else, returns the current
	 * value.
	 */
	@Override
	public Value concatenate(Value value) {
		SortedMap<Integer, FactoredWord> concat =
				new TreeMap<Integer, FactoredWord>(parsedInput);
		if (value instanceof ParseValue) {
			concat.putAll(((ParseValue) value).parsedInput);
		}
		else {
			log.warning("cannot concatenate " + toString() + " and " + value);
		}
		return new ParseValue(concat);
	}

	/**
	 * Representation of a word together with its POS-tag, index to its head, and
	 * labelled relation to the head.
	 *
	 */
	final class FactoredWord {

		int i;
		String word;
		String posTag;
		int head;
		String headRelation;

		/**
		 * Creates a new factored word
		 * 
		 * @param word the word
		 * @param posTag the POS-tag
		 * @param head the index to the head (0 if root)
		 * @param headRelation relation label with the head (null if root)
		 */
		public FactoredWord(int i, String word, String posTag, int head,
				String headRelation) {
			this.i = i;
			this.word = word;
			this.posTag = posTag;
			this.head = head;
			this.headRelation = headRelation;
		}

		/**
		 * Returns a string representation of the factored word
		 */
		@Override
		public String toString() {
			return "(" + i + "," + word + "," + posTag + "," + headRelation + ","
					+ head + ")";
		}

		/**
		 * Returns the hashcode for the factored word
		 */
		@Override
		public int hashCode() {
			return (i + word.hashCode() - posTag.hashCode() + head
					- headRelation.hashCode());
		}

		/**
		 * Returns true if o is a factored word with identical content, and false
		 * otherwise.
		 */
		@Override
		public boolean equals(Object o) {
			if (o instanceof FactoredWord) {
				FactoredWord fw = (FactoredWord) o;
				return (i == fw.i && fw.word.equals(word) && fw.posTag.equals(posTag)
						&& fw.head == head && fw.headRelation.equals(headRelation));
			}
			return false;
		}
	}

}
